01 Question: 1509번

세준이는 어떤 문자열을 팰린드롬으로 분할하려고 한다. 예를 들어, ABACABA를 팰린드롬으로 분할하면, {A, B, A, C, A, B, A}, {A, BACAB, A}, {ABA, C, ABA}, {ABACABA}등이 있다.

분할의 개수의 최솟값을 출력하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
01 MySolution: 1509번

#include <iostream> 
#include <cstring>
 
#define INF 1e9+7
 
using namespace std;
 
bool dp[2501][2501];
string str;
int N, res[2501];
 
bool is_palin(int st, int ed){
    if(ed > N) return false;
    
    if(str[st] == str[ed]){
        if(dp[st+1][ed-1] || ed-st == 1){
            return true;
        }
    }
    return false;
}
 
void fill_dptable(){
    for(int d = 0; d < N; d++){
        for(int i = 1; i+d <= N; i++){
            if(d == 0){
                dp[i][i] = true;
                continue;
            }
            if(is_palin(i, i+d)){
                dp[i][i+d] = true;
            }
        }
    }
}
 
void solve(){
    fill_dptable();
    
    res[0] = 0;
    for (int i = 1; i <= N; i++) {
        res[i] = INF;
        for (int j = 1; j <= i; j++) {
            if (dp[j][i]) {
                if (res[i] > res[j-1]+1) {
                    res[i] = res[j-1]+1;
                }
            }
        }
    }
    cout << res[N];
}
 
int main(){
    cin >> str;
    N = str.size();
    str = " " + str;
    solve();
    
    return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 2169번

NASA에서는 화성 탐사를 위해 화성에 무선 조종 로봇을 보냈다. 실제 화성의 모습은 굉장히 복잡하지만, 로봇의 메모리가 얼마 안 되기 때문에 지형을 N×M 배열로 단순화 하여 생각하기로 한다.

지형의 고저차의 특성상, 로봇은 움직일 때 배열에서 왼쪽, 오른쪽, 아래쪽으로 이동할 수 있지만, 위쪽으로는 이동할 수 없다. 또한 한 번 탐사한 지역(배열에서 하나의 칸)은 탐사하지 않기로 한다.

각각의 지역은 탐사 가치가 있는데, 로봇을 배열의 왼쪽 위 (1, 1)에서 출발시켜 오른쪽 아래 (N, M)으로 보내려고 한다. 이때, 위의 조건을 만족하면서, 탐사한 지역들의 가치의 합이 최대가 되도록 하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
02 MySolution: 2169번

#include <iostream>
#include <algorithm>
using namespace std;
int arr[1001][1001];
int dp[1001][1001][3];
int side[3][2] = { {0,-1},{0,1},{1,0} };
bool visit[1001][1001];
int N, M;
int DFS(int y, int x, int dir)
{
	if (y == N - 1 && x == M - 1)
		return arr[y][x];

	if (dp[y][x][dir] != -987654321)
		return dp[y][x][dir];

	for (int i = 0; i < 3; i++)
	{
		int ny = y + side[i][0];
		int nx = x + side[i][1];

		if (ny >= 0 && nx >= 0 && nx < M && ny < N && visit[ny][nx] == false)
		{
			visit[ny][nx] = true;
			dp[y][x][dir] = max(dp[y][x][dir], arr[y][x] + DFS(ny, nx, i));
			visit[ny][nx] = false;
		}
	}

	return dp[y][x][dir];
}
int main(void)
{
	cin >> N >> M;
	for(int i=0;i<N;i++)
		for (int j = 0; j < M; j++)
		{
			cin >> arr[i][j];

			dp[i][j][0] = -987654321;
			dp[i][j][1] = -987654321;
			dp[i][j][2] = -987654321;
			visit[i][j] = false;
		}
	visit[0][0] = true;
	cout << DFS(0, 0, 0);

}

----------------------------------------------------------------------------
----------------------------------------------------------------------------
