01 Question: 2150번

방향 그래프가 주어졌을 때, 그 그래프를 SCC들로 나누는 프로그램을 작성하시오.

방향 그래프의 SCC는 우선 정점의 최대 부분집합이며, 그 부분집합에 들어있는 서로 다른 임의의 두 정점 u, v에 대해서 u에서 v로 가는 경로와 v에서 u로 가는 경로가 모두 존재하는 경우를 말한다.

예를 들어 위와 같은 그림을 보자. 이 그래프에서 SCC들은 {a, b, e}, {c, d}, {f, g}, {h} 가 있다. 물론 h에서 h로 가는 간선이 없는 경우에도 {h}는 SCC를 이룬다.
----------------------------------------------------------------------------
01 MySolution: 2150번

#include<iostream>
#include<vector>
#include<stack>
#include<algorithm>
using namespace std;

int vertex_num, edge_num;
vector<vector<int>> adj;
stack<int> st;
vector<int> visited_order;
vector<bool> is_scc;
vector<vector<int>> sccs;
int order=0;

int FindSCC(int now_idx){
  int min_order = visited_order[now_idx] = ++order;
  int next_idx;
  st.push(now_idx);

  for(int i=0 ; i<adj[now_idx].size() ; ++i){
    next_idx = adj[now_idx][i];
    if(visited_order[next_idx] == -1)
      min_order = min(min_order, FindSCC(next_idx));
    else if(!is_scc[next_idx])
      min_order = min(min_order, visited_order[next_idx]);
  } 

  if(min_order == visited_order[now_idx]){
    int temp;
    vector<int> new_scc;
    while(1){
      temp = st.top();
      st.pop();
      is_scc[temp] = true;
      new_scc.push_back(temp);
      if(temp == now_idx)
        break;
    }

    sccs.push_back(new_scc);
  }
  return min_order;
}

bool Comp(vector<int>& va, vector<int>& vb){
  return va[0] < vb[0];
}

int main(){
  ios_base::sync_with_stdio(0);
  cin>>vertex_num>>edge_num;

  adj = vector<vector<int>>(vertex_num+1);
  is_scc = vector<bool>(vertex_num+1, false);
  visited_order = vector<int>(vertex_num+1, -1);

  int u,v;
  for(int i=0; i<edge_num ; ++i){
    cin>>u>>v;
    adj[u].push_back(v);
  }

  for(int idx =1; idx<=vertex_num ; ++idx)
    if(visited_order[idx] == -1)
      FindSCC(idx);
  
  for(int i=0; i<sccs.size() ; ++i)
    sort(sccs[i].begin(), sccs[i].end());

  sort(sccs.begin(), sccs.end(), Comp);

  cout<<sccs.size()<<"\n";
  for(int i=0; i<sccs.size() ; ++i){
    for(int j=0; j<sccs[i].size() ; ++j)
      cout<<sccs[i][j]<<' ';
    cout<<"-1\n";
  }

  return 0;
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 4196번

도미노는 재밌다. 도미노 블록을 일렬로 길게 늘어세운 뒤 블록 하나를 넘어뜨리면 그 블록이 넘어지며 다음 블록을 넘어뜨리는 일이 반복되어 일렬로 늘어선 블록들을 연쇄적으로 모두 쓰러뜨릴 수 있다. 그러나, 가끔씩 도미노가 다른 블록을 넘어뜨리지 못하게 배치되어 있다면, 우리는 다음 블록을 수동으로 넘어뜨려야 한다.

이제 각 도미노 블록의 배치가 주어졌을 때, 모든 블록을 넘어뜨리기 위해 손으로 넘어뜨려야 하는 블록 개수의 최솟값을 구하자.
----------------------------------------------------------------------------
02 MySolution: 4196번

#include <iostream>
#include <vector>
#include <cstring>
 
using namespace std;
 
int N, M;
vector< vector<int> > adj;
vector<int> stk;
 
int sccindegree[100001];
int SCCID[100001];
int Vertexcnt, SCCcnt;
int discovered[100001];
 
int SCC(int now){
    int ret = discovered[now] = Vertexcnt++;
    
    stk.push_back(now);
    
    for(auto &next : adj[now]){
        if(discovered[next] == -1){
            ret = min(ret, SCC(next));
        }
        else if(SCCID[next] == -1){
            ret = min(ret, discovered[next]);
        }
    }
    
    if(ret == discovered[now]){
        while(1){
            int temp = stk.back();
            stk.pop_back();
            SCCID[temp] = SCCcnt;
            if(temp == now) break;
        }
        SCCcnt++;
    }
    
    return ret;
}
 
void init(){
    memset(discovered, -1, sizeof(discovered));
    memset(SCCID, -1, sizeof(SCCID));
    memset(sccindegree, 0, sizeof(sccindegree));
    adj.clear();
    adj.resize(N+1, vector<int>());
    Vertexcnt = SCCcnt = 0;
    
    int u, v;
    for(int i = 0; i < M; i++){
        cin >> u >> v;
        adj[u].push_back(v);
    }
}
 
void solve(){
    int result = 0;
    
    for(int i = 1; i <= N; i++){
        if(discovered[i] != -1) continue;
        SCC(i);
    }
    
    for(int i = 1; i <= N; i++){
        for(auto &w : adj[i]){
            if(SCCID[w] == SCCID[i]) continue;
            sccindegree[SCCID[w]]++;
        }
    }
    
    for(int i = 0; i < SCCcnt; i++){
        if(!sccindegree[i]) result++;
    }
    
    cout << result << "\n";
}
 
int main(){
    ios::sync_with_stdio(0), cin.tie(0);
    int test;
    cin >> test;
    while(test--){
        cin >> N >> M;
        
        init();
        solve();
        
    }
    
    return 0;
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------
