01 Question: 2150번

방향 그래프가 주어졌을 때, 그 그래프를 SCC들로 나누는 프로그램을 작성하시오.

방향 그래프의 SCC는 우선 정점의 최대 부분집합이며, 그 부분집합에 들어있는 서로 다른 임의의 두 정점 u, v에 대해서 u에서 v로 가는 경로와 v에서 u로 가는 경로가 모두 존재하는 경우를 말한다.

예를 들어 위와 같은 그림을 보자. 이 그래프에서 SCC들은 {a, b, e}, {c, d}, {f, g}, {h} 가 있다. 물론 h에서 h로 가는 간선이 없는 경우에도 {h}는 SCC를 이룬다.
----------------------------------------------------------------------------
01 MySolution: 2150번

#include<iostream>
#include<vector>
#include<stack>
#include<algorithm>
using namespace std;

int vertex_num, edge_num;
vector<vector<int>> adj;
stack<int> st;
vector<int> visited_order;
vector<bool> is_scc;
vector<vector<int>> sccs;
int order=0;

int FindSCC(int now_idx){
  int min_order = visited_order[now_idx] = ++order;
  int next_idx;
  st.push(now_idx);

  for(int i=0 ; i<adj[now_idx].size() ; ++i){
    next_idx = adj[now_idx][i];
    if(visited_order[next_idx] == -1)
      min_order = min(min_order, FindSCC(next_idx));
    else if(!is_scc[next_idx])
      min_order = min(min_order, visited_order[next_idx]);
  } 

  if(min_order == visited_order[now_idx]){
    int temp;
    vector<int> new_scc;
    while(1){
      temp = st.top();
      st.pop();
      is_scc[temp] = true;
      new_scc.push_back(temp);
      if(temp == now_idx)
        break;
    }

    sccs.push_back(new_scc);
  }
  return min_order;
}

bool Comp(vector<int>& va, vector<int>& vb){
  return va[0] < vb[0];
}

int main(){
  ios_base::sync_with_stdio(0);
  cin>>vertex_num>>edge_num;

  adj = vector<vector<int>>(vertex_num+1);
  is_scc = vector<bool>(vertex_num+1, false);
  visited_order = vector<int>(vertex_num+1, -1);

  int u,v;
  for(int i=0; i<edge_num ; ++i){
    cin>>u>>v;
    adj[u].push_back(v);
  }

  for(int idx =1; idx<=vertex_num ; ++idx)
    if(visited_order[idx] == -1)
      FindSCC(idx);
  
  for(int i=0; i<sccs.size() ; ++i)
    sort(sccs[i].begin(), sccs[i].end());

  sort(sccs.begin(), sccs.end(), Comp);

  cout<<sccs.size()<<"\n";
  for(int i=0; i<sccs.size() ; ++i){
    for(int j=0; j<sccs[i].size() ; ++j)
      cout<<sccs[i][j]<<' ';
    cout<<"-1\n";
  }

  return 0;
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 4196번

도미노는 재밌다. 도미노 블록을 일렬로 길게 늘어세운 뒤 블록 하나를 넘어뜨리면 그 블록이 넘어지며 다음 블록을 넘어뜨리는 일이 반복되어 일렬로 늘어선 블록들을 연쇄적으로 모두 쓰러뜨릴 수 있다. 그러나, 가끔씩 도미노가 다른 블록을 넘어뜨리지 못하게 배치되어 있다면, 우리는 다음 블록을 수동으로 넘어뜨려야 한다.

이제 각 도미노 블록의 배치가 주어졌을 때, 모든 블록을 넘어뜨리기 위해 손으로 넘어뜨려야 하는 블록 개수의 최솟값을 구하자.
----------------------------------------------------------------------------
02 MySolution: 4196번

#include <iostream>
#include <vector>
#include <cstring>
 
using namespace std;
 
int N, M;
vector< vector<int> > adj;
vector<int> stk;
 
int sccindegree[100001];
int SCCID[100001];
int Vertexcnt, SCCcnt;
int discovered[100001];
 
int SCC(int now){
    int ret = discovered[now] = Vertexcnt++;
    
    stk.push_back(now);
    
    for(auto &next : adj[now]){
        if(discovered[next] == -1){
            ret = min(ret, SCC(next));
        }
        else if(SCCID[next] == -1){
            ret = min(ret, discovered[next]);
        }
    }
    
    if(ret == discovered[now]){
        while(1){
            int temp = stk.back();
            stk.pop_back();
            SCCID[temp] = SCCcnt;
            if(temp == now) break;
        }
        SCCcnt++;
    }
    
    return ret;
}
 
void init(){
    memset(discovered, -1, sizeof(discovered));
    memset(SCCID, -1, sizeof(SCCID));
    memset(sccindegree, 0, sizeof(sccindegree));
    adj.clear();
    adj.resize(N+1, vector<int>());
    Vertexcnt = SCCcnt = 0;
    
    int u, v;
    for(int i = 0; i < M; i++){
        cin >> u >> v;
        adj[u].push_back(v);
    }
}
 
void solve(){
    int result = 0;
    
    for(int i = 1; i <= N; i++){
        if(discovered[i] != -1) continue;
        SCC(i);
    }
    
    for(int i = 1; i <= N; i++){
        for(auto &w : adj[i]){
            if(SCCID[w] == SCCID[i]) continue;
            sccindegree[SCCID[w]]++;
        }
    }
    
    for(int i = 0; i < SCCcnt; i++){
        if(!sccindegree[i]) result++;
    }
    
    cout << result << "\n";
}
 
int main(){
    ios::sync_with_stdio(0), cin.tie(0);
    int test;
    cin >> test;
    while(test--){
        cin >> N >> M;
        
        init();
        solve();
        
    }
    
    return 0;
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 3977번

World Soccer Championship이 다가오고 있다! 천재적인 전술을 창조하는 플랜 아티스트 감독 도현이는 자신의 팀이 승리하도록 만반의 준비를 가하고 있다. 도현이의 전략은 경기장을 여러 개의 구역으로 나누고, 어떤 선수가 A구역에서 B구역으로 이동하게 하는 움직임을 (A, B)로 표현한다. 모든 도현이의 팀 선수들이 이 움직임만을 따라서 이동한다면 승리하리라고 도현이는 확신한다.

도현이는 선수들에게 자신의 전술을 말해주며, 다른 모든 구역에 도달할 수 있는 시작 구역을 찾은 뒤 지시한 움직임만을 따라가라고 했다. 그러나 도현이는 한 가지 간과한 것이 있었는데 그건 선수들이 자신만큼 똑똑하지 않다는 것이다. 선수들은 그러한 시작 구역을 찾는 것이 어려웠다. 이제 당신이 적절한 시작 구역을 찾아줘야 한다.
----------------------------------------------------------------------------
02 MySolution: 3977번

#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <stack>

using namespace std;

const int MAX_N = 100001;

int T;
int N, M;
vector<int> adj[MAX_N];

stack<int> st;
int discover[MAX_N], scc[MAX_N];
int sccCnt, sccSize;
vector<int> SCCNode[MAX_N];
bool repreSCC[MAX_N];
int startSCC;

int dfs(int no) {
    st.push(no);
    discover[no] = sccCnt++;
    int parent = discover[no];
    
    for(auto next : adj[no]) {
        if(discover[next] == -1)
            parent = min(parent, dfs(next));
        else if(scc[next] == -1)
            parent = min(parent, discover[next]);
    }
    
    if(parent == discover[no]) {
        while(true) {
            int x = st.top();
            st.pop();
            scc[x] = sccSize;
            SCCNode[sccSize].push_back(x);
            if(no == x)
                break;
        }
        sccSize++;
    }
    
    return parent;
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    
    cin >> T;
    while(T--) {
        for(int i=0; i<MAX_N; i++) {
            adj[i].clear();
            SCCNode[i].clear();
        }
        memset(discover, -1, sizeof discover);
        memset(scc, -1, sizeof scc);
        sccCnt = sccSize = 1;
        fill(repreSCC, repreSCC+MAX_N, true);
        
        cin >> N >> M;
        for(int i=0; i<M; i++) {
            int a, b;
            cin >> a >> b;
            adj[a].push_back(b);
        }
        
        for(int i=0; i<N; i++) {
            if(discover[i] == -1)
                dfs(i);
        }

        for(int i=0; i<N; i++)
            for(auto next : adj[i])
                if(scc[i] != scc[next])
                    repreSCC[scc[next]] = false;
        
        sccSize--;
        int cnt = 0;
        for(int i=1; i<=sccSize; i++) {
            if(repreSCC[i]) {
                cnt++;
                startSCC = i;
            }
        }
        
        if(!cnt) {
            for(int i=0; i<N; i++)
                cout << i << '\n';
        }
        else if(cnt == 1) {
            sort(SCCNode[startSCC].begin(), SCCNode[startSCC].end());
            for(auto x : SCCNode[startSCC]) {
                cout << x << '\n';
            }
        }
        else
            cout << "Confused" << '\n';
        cout << '\n';
    }
    
    return 0;
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------
