01 Question: 3584번

루트가 있는 트리(rooted tree)가 주어지고, 그 트리 상의 두 정점이 주어질 때 그들의 가장 가까운 공통 조상(Nearest Common Ancestor)은 다음과 같이 정의됩니다.

두 노드의 가장 가까운 공통 조상은, 두 노드를 모두 자손으로 가지면서 깊이가 가장 깊은(즉 두 노드에 가장 가까운) 노드를 말합니다.
nca.png

예를 들어 15와 11를 모두 자손으로 갖는 노드는 4와 8이 있지만, 그 중 깊이가 가장 깊은(15와 11에 가장 가까운) 노드는 4 이므로 가장 가까운 공통 조상은 4가 됩니다.

루트가 있는 트리가 주어지고, 두 노드가 주어질 때 그 두 노드의 가장 가까운 공통 조상을 찾는 프로그램을 작성하세요
----------------------------------------------------------------------------
01 MySolution: 3584번

#include<iostream>
#include<algorithm>
using namespace std;

int parent[10001];
bool visit[10001];
int T, N, A, B, u, v;

int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);

	cin >> T;

	while (T--)
	{
		cin >> N;

		for (int i = 1; i <= N; i++)
		{
			visit[i] = false;
			parent[i] = i;
		}

		for (int i = 0; i < N - 1; i++)
		{
			cin >> A >> B;
			parent[B] = A;
		}

		cin >> u >> v;
		visit[u] = true;

		while (u != parent[u])
		{
			u = parent[u];
			visit[u] = true;
		}
		while (true)
		{
			if (visit[v])
			{
				cout << v << '\n';
				break;
			}
			v = parent[v];
		}
		
	}
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 17435번

함수 f : {1, 2, ..., m}→{1, 2, ..., m}이 있다. 이때 fn : {1, 2, ..., m}→{1, 2, ..., m}을 다음과 같이 정의하자.

f1(x) = f(x)
fn+1(x) = f(fn(x))
예를 들어 f4(1) = f(f(f(f(1))))이다.

n과 x가 주어질 때 fn(x)를 계산하는 쿼리를 수행하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
02 MySolution: 17435번

#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int m;
int Q;
int n, x;
int f[200001];
#define max_log 20
int table[21][200001];

void init()
{
	cin >> m;
	for (int i = 1; i <= m; i++) {
		int num;
		cin >> num;
		f[i] = num;
	}

	for (int i = 1; i <= m; i++)
		table[0][i] = f[i];

	for (int i = 1; i < max_log; i++) {
		for (int j = 1; j <= m; j++) {
			int tmp = table[i - 1][j];
			table[i][j] = table[i - 1][tmp];
		}
	}
}


int solve(int n, int x)
{
	int cur = x;
	for (int k = 0; k < max_log; k++) {
		if (n & (1 << k)) {
			cur = table[k][cur];
		}
	}
	return cur;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	init();

	cin >> Q;
	while (Q--) {
		cin >> n >> x;
		
		int res = solve(n, x);
		cout << res << '\n';
	}
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------

03 Question: 11438번

N(2 ≤ N ≤ 100,000)개의 정점으로 이루어진 트리가 주어진다. 트리의 각 정점은 1번부터 N번까지 번호가 매겨져 있으며, 루트는 1번이다.

두 노드의 쌍 M(1 ≤ M ≤ 100,000)개가 주어졌을 때, 두 노드의 가장 가까운 공통 조상이 몇 번인지 출력한다.
----------------------------------------------------------------------------
03 MySolution: 11438번

#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int m;
int Q;
int n, x;
int f[200001];
#define max_log 20
int table[21][200001];

void init()
{
	cin >> m;
	for (int i = 1; i <= m; i++) {
		int num;
		cin >> num;
		f[i] = num;
	}

	for (int i = 1; i <= m; i++)
		table[0][i] = f[i];

	for (int i = 1; i < max_log; i++) {
		for (int j = 1; j <= m; j++) {
			int tmp = table[i - 1][j];
			table[i][j] = table[i - 1][tmp];
		}
	}
}


int solve(int n, int x)
{
	int cur = x;
	for (int k = 0; k < max_log; k++) {
		if (n & (1 << k)) {
			cur = table[k][cur];
		}
	}
	return cur;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	init();

	cin >> Q;
	while (Q--) {
		cin >> n >> x;
		
		int res = solve(n, x);
		cout << res << '\n';
	}
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------
