01 Question: 3584번

루트가 있는 트리(rooted tree)가 주어지고, 그 트리 상의 두 정점이 주어질 때 그들의 가장 가까운 공통 조상(Nearest Common Ancestor)은 다음과 같이 정의됩니다.

두 노드의 가장 가까운 공통 조상은, 두 노드를 모두 자손으로 가지면서 깊이가 가장 깊은(즉 두 노드에 가장 가까운) 노드를 말합니다.
nca.png

예를 들어 15와 11를 모두 자손으로 갖는 노드는 4와 8이 있지만, 그 중 깊이가 가장 깊은(15와 11에 가장 가까운) 노드는 4 이므로 가장 가까운 공통 조상은 4가 됩니다.

루트가 있는 트리가 주어지고, 두 노드가 주어질 때 그 두 노드의 가장 가까운 공통 조상을 찾는 프로그램을 작성하세요
----------------------------------------------------------------------------
01 MySolution: 3584번

#include<iostream>
#include<algorithm>
using namespace std;

int parent[10001];
bool visit[10001];
int T, N, A, B, u, v;

int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);

	cin >> T;

	while (T--)
	{
		cin >> N;

		for (int i = 1; i <= N; i++)
		{
			visit[i] = false;
			parent[i] = i;
		}

		for (int i = 0; i < N - 1; i++)
		{
			cin >> A >> B;
			parent[B] = A;
		}

		cin >> u >> v;
		visit[u] = true;

		while (u != parent[u])
		{
			u = parent[u];
			visit[u] = true;
		}
		while (true)
		{
			if (visit[v])
			{
				cout << v << '\n';
				break;
			}
			v = parent[v];
		}
		
	}
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 17435번

함수 f : {1, 2, ..., m}→{1, 2, ..., m}이 있다. 이때 fn : {1, 2, ..., m}→{1, 2, ..., m}을 다음과 같이 정의하자.

f1(x) = f(x)
fn+1(x) = f(fn(x))
예를 들어 f4(1) = f(f(f(f(1))))이다.

n과 x가 주어질 때 fn(x)를 계산하는 쿼리를 수행하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
02 MySolution: 17435번

#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int m;
int Q;
int n, x;
int f[200001];
#define max_log 20
int table[21][200001];

void init()
{
	cin >> m;
	for (int i = 1; i <= m; i++) {
		int num;
		cin >> num;
		f[i] = num;
	}

	for (int i = 1; i <= m; i++)
		table[0][i] = f[i];

	for (int i = 1; i < max_log; i++) {
		for (int j = 1; j <= m; j++) {
			int tmp = table[i - 1][j];
			table[i][j] = table[i - 1][tmp];
		}
	}
}


int solve(int n, int x)
{
	int cur = x;
	for (int k = 0; k < max_log; k++) {
		if (n & (1 << k)) {
			cur = table[k][cur];
		}
	}
	return cur;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	init();

	cin >> Q;
	while (Q--) {
		cin >> n >> x;
		
		int res = solve(n, x);
		cout << res << '\n';
	}
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------

03 Question: 11438번

N(2 ≤ N ≤ 100,000)개의 정점으로 이루어진 트리가 주어진다. 트리의 각 정점은 1번부터 N번까지 번호가 매겨져 있으며, 루트는 1번이다.

두 노드의 쌍 M(1 ≤ M ≤ 100,000)개가 주어졌을 때, 두 노드의 가장 가까운 공통 조상이 몇 번인지 출력한다.
----------------------------------------------------------------------------
03 MySolution: 11438번

#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <utility>

using namespace std;
#define PMAX 25
#define MAX 100001

vector<int> adj[MAX];
int d[MAX] = { 0, };
int p[MAX][PMAX] = { 0, };

void bfs(int s) {
	queue<int> q;
	q.push(s);
	d[s] = 1;
	p[s][0] = -1;
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		for (int i = 0; i < adj[cur].size(); i++) {
			int nxt = adj[cur][i];
			if (d[nxt] == 0) {
				p[nxt][0] = cur;
				d[nxt] = d[cur] + 1;
				q.push(nxt);
			}
		}
	}
}

void getP(int n) {
	for (int j = 1; (1 << j) < n; j++) {
		for (int i = 1; i <= n; i++) {
			if (p[i][j - 1] != 0) p[i][j] = p[p[i][j - 1]][j - 1];
		}
	}
}

int LCA(int a, int b) {
	if (d[a] < d[b])
		swap(a, b);
	if (d[a] != d[b])
		for (int j = PMAX; j >= 0; --j)
			if (d[a] - (1 << j) >= d[b])
				a = p[a][j];
	if (a == b)
		return a;
	else {
		for (int j = PMAX; j >= 0; --j) {
			if (d[a] - (1 << j) >= 0 && p[a][j] != p[b][j]) {
				a = p[a][j];
				b = p[b][j];
			}
		}
	}
	return p[a][0];
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int N, M, a, b;
	cin >> N;
	for (int i = 0; i < N - 1; i++) {
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	bfs(1);
	getP(N);
	cin >> M;
	while (M--) {
		cin >> a >> b;
		cout << LCA(a, b) << "\n";
	}
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------
