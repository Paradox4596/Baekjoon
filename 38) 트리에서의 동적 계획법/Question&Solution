01 Question: 15681번

간선에 가중치와 방향성이 없는 임의의 루트 있는 트리가 주어졌을 때, 아래의 쿼리에 답해보도록 하자.

정점 U를 루트로 하는 서브트리에 속한 정점의 수를 출력한다.
만약 이 문제를 해결하는 데에 어려움이 있다면, 하단의 힌트에 첨부한 문서를 참고하자.
----------------------------------------------------------------------------
01 MySolution: 15681번

#include <iostream>
#include <vector>
using namespace std;
vector<int> v[100001];
bool visit[100001] = { false, };
int num[100001];
int node, query, s, e;

int dfs(int n) {
	if (num[n] != 0) return num[n];
	visit[n] = true;
	int ret = 1;
	for (int i = 0; i < v[n].size(); i++) {
		int next = v[n][i];
		if (visit[next]) continue;
		ret += dfs(next);
	}
	num[n] = ret;
	return ret;
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	int root;
	cin >> node >> root >> query;
	for (int i = 0; i < node - 1; i++) {
		cin >> s >> e;
		v[s].push_back(e);
		v[e].push_back(s);
	}
	num[root] = dfs(root);
	for (int i = 0; i < query; i++) {
		cin >> s;
		cout << num[s] << '\n';
	}
	return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 2213번

그래프 G(V, E)에서 정점의 부분 집합 S에 속한 모든 정점쌍이 서로 인접하지 않으면 (정점쌍을 잇는 간선이 없으면) S를 독립 집합(independent set)이라고 한다. 독립 집합의 크기는 정점에 가중치가 주어져 있지 않을 경우는 독립 집합에 속한 정점의 수를 말하고, 정점에 가중치가 주어져 있으면 독립 집합에 속한 정점의 가중치의 합으로 정의한다. 독립 집합이 공집합일 때 그 크기는 0이라고 하자. 크기가 최대인 독립 집합을 최대 독립 집합이라고 한다.

문제는 일반적인 그래프가 아니라 트리(연결되어 있고 사이클이 없는 그래프)와 각 정점의 가중치가 양의 정수로 주어져 있을 때, 최대 독립 집합을 구하는 것이다.
----------------------------------------------------------------------------
02 MySolution: 2213번

#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>

using namespace std;
int N;
struct P {int inc, n_inc;};
const int INC = 1, N_INC = 2;
vector<int> ans;
short choice[10003];

P dfs(vector<int> G[], P arr[], int v, bool visited[]) {
    visited[v] = true;
    for(int adj:G[v]) {
        if(!visited[adj]) {
            P tmp = dfs(G,arr,adj,visited);
            arr[v].inc += tmp.n_inc;
            arr[v].n_inc += max(tmp.n_inc, tmp.inc);
            if (arr[adj].inc > arr[adj].n_inc) choice[adj] = INC;
            else choice[adj] = N_INC;
        }
    }
    return arr[v];
}

void chosen(vector<int> G[], bool visited[], int cur, int Choice) {
    visited[cur] = true;
    if (Choice == INC) {
        ans.push_back(cur);
        for (auto next : G[cur]) {
            if(!visited[next]) chosen(G, visited, next, N_INC);
        }
    } else {
        for(auto next : G[cur])
            if(!visited[next]) chosen(G, visited, next, choice[next]);
    }
}

int main() {
    scanf("%d",&N);
    P arr[N+1];
    for(int i=1;i<=N;++i)
        arr[i] = {1,0};
    for(int i=1;i<=N;++i)
        scanf("%d",&arr[i].inc);
    vector<int> G[N+1];
    for(int i=0;i<N-1;++i) {
        int u, v;
        scanf("%d%d",&u,&v);
        G[u].push_back(v);
        G[v].push_back(u);
    }

    bool visited[N+1];
    memset(visited,0, sizeof(visited));

    dfs(G,arr,1,visited);

    memset(visited,0, sizeof(visited));
    if (arr[1].inc > arr[1].n_inc)
        chosen(G,visited,1,INC);
    else
        chosen(G,visited,1,N_INC);
    printf("%d\n",max(arr[1].inc, arr[1].n_inc));
    sort(ans.begin(),ans.end());
    for(auto e:ans)
        printf("%d ",e);
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------
