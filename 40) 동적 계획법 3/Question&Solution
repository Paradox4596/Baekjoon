01 Question: 11723번

비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.

add x: S에 x를 추가한다. (1 ≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.
remove x: S에서 x를 제거한다. (1 ≤ x ≤ 20) S에 x가 없는 경우에는 연산을 무시한다.
check x: S에 x가 있으면 1을, 없으면 0을 출력한다. (1 ≤ x ≤ 20)
toggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 ≤ x ≤ 20)
all: S를 {1, 2, ..., 20} 으로 바꾼다.
empty: S를 공집합으로 바꾼다.
----------------------------------------------------------------------------
01 MySolution: 11723번

#include <iostream>
#include <string>
using namespace std;
 
int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    unsigned int s = 0;
    int m, n;
    string a ="";
    cin >> m;
    while(m--){
        cin >> a;
        if(a=="add"){
            cin >> n;
            s |= (1 << n);
        }else if(a == "remove"){
            cin >> n;
            s &= ~(1 << n);
        }else if(a== "check"){
            cin >> n;
            if(s & (1<<n)){
                cout << 1 << '\n';
            }else{
                cout << 0 << '\n';
            }
        }else if(a=="toggle"){
            cin >> n;
            s ^= (1<<n);
        }else if(a=="all"){
            s = (1 << 21) - 1;
        }else if(a == "empty"){
            s = 0;
        }
    }
    return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 1311번

N명의 사람과 N개의 일이 있다. 각 사람은 일을 하나 담당해야 하고, 각 일을 담당하는 사람은 한 명 이어야 한다. 또한, 모든 사람은 모든 일을 할 능력이 있다.

사람은 1번부터 N번까지 번호가 매겨져 있으며, 일도 1번부터 N번까지 번호가 매겨져 있다.

Dij를 i번 사람이 j번 일을 할 때 필요한 비용이라고 했을 때, 모든 일을 하는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
02 MySolution: 1311번

#include<iostream>
#include<vector>
#include<algorithm>
#include<cmath>

using namespace std;

int n;
vector<int>work[21];
vector<int>dp;
int inf = 987654321;

void make_works()
{
	cin >> n;
	for (int i = 0; i < n; i++){
		for (int j = 0; j < n; j++) {
			int w;
			cin >> w;
			work[i].push_back(w);
		}
	}
}


int count_bit(int num)
{
	int cnt = 0;
	while (num) {
		cnt += (num & 1);
		num >>= 1;
	}
	return cnt;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	make_works();
	
	for (int i = 0; i < pow(2, n); i++) {
		dp.push_back(inf);
	}
	dp[0] = 0;

	for (int i = 0; i < pow(2, n); i++) {
		int x = count_bit(i);
		for (int j = 0; j < n; j++) {
			if (!(i & (1 << j))) {
				dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + work[x][j]);
			}
		}
	}

	cout << dp[dp.size() - 1];
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

03 Question: 2098번

외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.

1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.

각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.

N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
03 MySolution: 2098번

#include <iostream>
#include <cstring>
using namespace std;

#define INF 987654321;

int n,map[16][16];
int dp[16][1<<16];

int dfs(int cur, int visit){
    
    if (visit == (1<<n)-1){
        if(map[cur][0] == 0)
            return INF;
        return map[cur][0];
    }
    
    if (dp[cur][visit] != -1)
        return dp[cur][visit];
    
    dp[cur][visit] = INF;
    
    for (int i=0; i<n; i++){
        if (map[cur][i]==0)
            continue;
        if ((visit & (1<<i)) == (1<<i))
            continue;
        dp[cur][visit] = min(dp[cur][visit], map[cur][i] + dfs(i, visit | 1<<i));
    }
    
    return dp[cur][visit];
}

int main(int argc, const char * argv[]) {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    
    cin>>n;
    for (int i=0; i<n; i++){
        for (int j=0; j<n; j++){
            cin>>map[i][j];
        }
    }
    
    memset(dp, -1, sizeof(dp));
    cout<<dfs(0,1);
    
    return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

04 Question: 1086번

박성원은 이 문제를 풀지 못했다.

서로 다른 정수로 이루어진 집합이 있다. 이 집합의 순열을 합치면 큰 정수 하나를 만들 수 있다. 예를 들어, {5221,40,1,58,9}로 5221401589를 만들 수 있다. 합친수가 정수 K로 나누어 떨어지는 순열을 구하는 프로그램을 작성하시오.

하지만, 박성원은 이 문제를 풀지 못했다.

따라서 박성원은 그냥 랜덤하게 순열 하나를 정답이라고 출력하려고 한다. 이 문제에는 정답이 여러 개 있을 수도 있고, 박성원이 우연히 문제의 정답을 맞출 수도 있다.

박성원이 우연히 정답을 맞출 확률을 분수로 출력하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
04 MySolution: 1086번

#include <bits/stdc++.h>
#define ft first
#define sd second
#define all(x) (x).begin(), (x).end()
#define mem(v, e) memset((v), (e), sizeof((v)))
using namespace std;
using ll = long long;
using pii = pair<int, int>;
 
int n, mod;
int tenPow[55];
string nums[22];
pii p[22];
ll d[1 << 15][111];
 
ll go(int s, int num) {
    if (s == (1 << n) - 1) return (num % mod == 0);
 
    ll &ret = d[s][num];
    if (ret != -1) return ret;
    ret = 0;
    for (int k = 0; k < n; k++) {
        if (s & (1 << k)) continue;
        auto[next, cnt] = p[k];
        ll nextNum = num * tenPow[cnt] + next;
        nextNum %= mod;
        ret += go(s | (1 << k), nextNum);
    }
    return ret;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
 
    cin >> n;
    ll all = 1;
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
        all *= (i + 1);
    }
    cin >> mod;
    tenPow[0] = 1 % mod;
    for (int i = 1; i < 55; i++) {
        tenPow[i] = (tenPow[i - 1] * 10) % mod;
    }
    for (int i = 0; i < n; i++) {
        reverse(all(nums[i]));
        p[i].sd = nums[i].size();
        for (int j = 0; j < nums[i].size(); j++) {
            p[i].ft += (nums[i][j] - '0') * tenPow[j] % mod;
 
        }
        p[i].ft %= mod;
    }
    mem(d, -1);
    ll cnt = go(0, 0);
    ll g = gcd(all, cnt);
    cout << cnt / g << "/" << all / g;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------
