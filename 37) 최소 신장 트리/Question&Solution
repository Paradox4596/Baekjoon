01 Question: 9372번

상근이는 겨울방학을 맞아 N개국을 여행하면서 자아를 찾기로 마음먹었다. 

하지만 상근이는 새로운 비행기를 무서워하기 때문에, 최대한 적은 종류의 비행기를 타고 국가들을 이동하려고 한다.

이번 방학 동안의 비행 스케줄이 주어졌을 때, 상근이가 가장 적은 종류의 비행기를 타고 모든 국가들을 여행할 수 있도록 도와주자.

상근이가 한 국가에서 다른 국가로 이동할 때 다른 국가를 거쳐 가도(심지어 이미 방문한 국가라도) 된다.
----------------------------------------------------------------------------
01 MySolution: 9372번

#include<iostream>
using namespace std;

int main(){
    int test, N ,M;
    int a,b;
    cin >> test;
    while(test--){
        cin >> N >> M;
        for(int i=0; i < M ; i++){
            cin >> a >> b;
        }
        cout << N-1 <<endl;
    }
    return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 1197번

그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오.

최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.
----------------------------------------------------------------------------
02 MySolution: 1197번

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std; 
int parent[10001];
int find(int x) {
	if (parent[x] == x)return x;
	else return parent[x] = find(parent[x]); 
}
void uni(int x, int y) {
	x = find(x); 
	y = find(y); 
	parent[y] = x; 
}
bool sameparent(int x, int y) {
	x = find(x); 
	y = find(y); 
	if (x == y)return true;
	else return false; 
}
int main() {
	int vertex, e; 
	cin >> vertex >> e;
	int result = 0; 
	vector<pair<int, pair<int, int>>>v; 
	for (int i = 0; i < e; i++) {
		int from, to, cost; 
		cin >> from >> to >> cost; 
		v.push_back({ cost,{from,to} }); 
	}
	sort(v.begin(), v.end()); 
	for (int i = 1; i <= vertex; i++)parent[i] = i; 
	for (int i = 0; i < v.size(); i++) {
		if (!sameparent(v[i].second.first, v[i].second.second)) {
			uni(v[i].second.first, v[i].second.second); 
			result += v[i].first; 
		}
	}
	cout << result; 
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

03 Question: 4386번

도현이는 우주의 신이다. 이제 도현이는 아무렇게나 널브러져 있는 n개의 별들을 이어서 별자리를 하나 만들 것이다. 별자리의 조건은 다음과 같다.

별자리를 이루는 선은 서로 다른 두 별을 일직선으로 이은 형태이다.
모든 별들은 별자리 위의 선을 통해 서로 직/간접적으로 이어져 있어야 한다.
별들이 2차원 평면 위에 놓여 있다. 선을 하나 이을 때마다 두 별 사이의 거리만큼의 비용이 든다고 할 때, 별자리를 만드는 최소 비용을 구하시오.
----------------------------------------------------------------------------
03 MySolution: 4386번

#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;
 
int n;
double x, y;
int connect[101] = {0, };
vector<pair<double, double>> stars;
vector<pair<double, pair<int, int>>> v;
double answer = 0;
 
int find(int a){
    if(a==connect[a]){
        return a;
    }
        
    return connect[a] = find(connect[a]);
}
 
double cal(double x1, double y1, double x2, double y2)
{
    return sqrt(pow(x2-x1, 2)+pow(y2-y1, 2));
}
 
int main()
{
    cin>>n;
    for(int i=0; i<n; i++){
        cin>>x>>y;
        stars.push_back(make_pair(x, y));
    }
 

    for(int i=0; i<stars.size(); i++){
        for(int j=i+1; j<stars.size(); j++){
            double cost = cal(stars[i].first, stars[i].second, stars[j].first, stars[j].second);
            v.push_back(make_pair(cost, make_pair(i, j)));
        }
    }
 
    for(int i=0; i<n; i++){
        connect[i] = i;
    }
 
    sort(v.begin(), v.end());
 
    for(int i=0; i<v.size(); i++){
        int x = v[i].second.first;
        int y = v[i].second.second;
        double cost = v[i].first;
 
        int a = find(x);
        int b = find(y);
 
        if(a!=b){
            connect[a] = b;
            answer += cost;
        }
    }
 
    cout.precision(3);
    cout<<answer<<"\n";
    return 0;
}


----------------------------------------------------------------------------
----------------------------------------------------------------------------
