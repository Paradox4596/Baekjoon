01 Question: 3273번

n개의 서로 다른 양의 정수 a1, a2, ..., an으로 이루어진 수열이 있다. ai의 값은 1보다 크거나 같고, 1000000보다 작거나 같은 자연수이다. 자연수 x가 주어졌을 때, ai + aj = x (1 ≤ i < j ≤ n)을 만족하는 (ai, aj)쌍의 수를 구하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
01 MySolution: 3273번

#include <iostream>
using namespace std;

int num[100001];

int main(void) {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	
	int n,tmp,x;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> num[i];
	}
	cin >> x;
	sort(num, num + n);
	int sum = 0;
	int left = 0, right = n - 1;
	while (left < right) {
		if (num[left] + num[right] == x) {
			sum += 1;
			left += 1;
			right -= 1;
		}
		else if (num[left] + num[right] > x) {
			right -= 1;
		}
		else {
			left += 1;
		}
	}
	cout << sum;
	
	return 0;
}


----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 2470번

KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.

같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.

예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.

산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.
----------------------------------------------------------------------------
02 MySolution: 2470번

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int compare(const void *a, const void *b){
    return *(int*)a - *(int*)b;
}
int main(){
    int N;
    scanf("%d", &N);
    int arr[N];
    for (int i = 0; i < N; i++)
        scanf("%d", &arr[i]);
    qsort(arr, N, sizeof(int), compare);
	
    int left = 0, right = N-1, sum = 2e9;
    int left_val = arr[left], right_val = arr[right];
    while (left < right){
        int temp = arr[left] + arr[right];
		
        if (abs(temp) < sum){
            sum = abs(temp);
            left_val = arr[left];
            right_val = arr[right];
        }
		
        temp < 0 ? ++left : --right;
    }
    printf("%d %d", left_val, right_val);
}


----------------------------------------------------------------------------
----------------------------------------------------------------------------

03 Question: 1806번

10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
03 MySolution: 1806번

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
	int n, s;
	cin >> n >> s;
	vector<int> arr(n);
	for (int i = 0; i < n; i++)
		cin >> arr[i];
	
	int start = 0, end = 0, sum = 0, minLen = 0x7FFFFFF;
	while (start <= end) {
		if (sum >= s) {
			minLen = min(minLen,end - start);
			sum -= arr[start++];
		}
		else if (end == n) break;
		else sum += arr[end++];
	}

	if (minLen == 0x7FFFFFF) cout << 0 << endl;
	else cout << minLen << endl;
	return 0;
}


----------------------------------------------------------------------------
----------------------------------------------------------------------------
