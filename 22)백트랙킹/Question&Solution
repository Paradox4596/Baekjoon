01 Question: 15649번

자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
----------------------------------------------------------------------------
01 MySolution: 15649번

#include <iostream>
#define MAX 9
using namespace std;

int n,m;
int arr[MAX] = {0,};
bool visited[MAX] = {0,};

void dfs(int cnt)
{
    if(cnt == m)
    {
        for(int i = 0; i < m; i++)
            cout << arr[i] << ' ';
        cout << '\n';
        return;
    }
    for(int i = 1; i <= n; i++)
    {
        if(!visited[i])
        {
            visited[i] = true;
            arr[cnt] = i;
            dfs(cnt+1);
            visited[i] = false;
        }
    }
}

int main() {
    cin >> n >> m;
    dfs(0);
}


----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 15650번

자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
고른 수열은 오름차순이어야 한다.
----------------------------------------------------------------------------
02 MySolution: 15650번

#include <iostream>

using namespace std;
#define MAX 9

int N,M;
int arr[MAX];

void dfs(int num, int k) {
    if(k==M) { // M까지 들어갔을 시 실행
        for(auto i =0;i<M;i++)
            cout << arr[i] << " ";
        cout << "\n";
    } else { // M까지 안 들어갔을 시
        for(auto i=num; i<=N;i++) {
            arr[k]=i; // 값 저장
            dfs(i+1,k+1); // 더 깊게 내려가자 (M까지)
        }
    }
}

int main() {
    cin >> N >> M;
    dfs(1,0);
}


----------------------------------------------------------------------------
----------------------------------------------------------------------------

03 Question: 15651번

자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
고른 수열은 오름차순이어야 한다.
----------------------------------------------------------------------------
03 MySolution: 15651번

#include <iostream>
#define MAX 9
using namespace std;

int n,m;
int arr[MAX] = {0,};
bool visited[MAX] = {0,};

void dfs(int cnt)
{
    if(cnt == m)
    {
        for(int i = 0; i < m; i++)
            cout << arr[i] << ' ';
        cout << '\n';
        return;
    }
    for(int i = 1; i <= n; i++)
    {
            visited[i] = true;
            arr[cnt] = i;
            dfs(cnt+1);
            visited[i] = false;
    }
}

int main() {
    cin >> n >> m;
    dfs(0);
}


----------------------------------------------------------------------------
----------------------------------------------------------------------------

04 Question: 15652번

자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

1부터 N까지 자연수 중에서 M개를 고른 수열
같은 수를 여러 번 골라도 된다.
고른 수열은 비내림차순이어야 한다.
길이가 K인 수열 A가 A1 ≤ A2 ≤ ... ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.
----------------------------------------------------------------------------
04 MySolution: 15652번

#include <iostream>
#define MAX 9
using namespace std;

int n,m;
int arr[MAX] = {0,};
bool visited[MAX] = {0,};

void dfs(int num, int cnt)
{
    if(cnt == m)
    {
        for(int i = 0; i < m; i++)
            cout << arr[i] << ' ';
        cout << '\n';
        return;
    }
    for(int i = num; i <= n; i++)
    {
            visited[i] = true;
            arr[cnt] = i;
            dfs(i,cnt+1);
            visited[i] = false;
    }
}

int main() {
    cin >> n >> m;
    dfs(1,0);
}


----------------------------------------------------------------------------
----------------------------------------------------------------------------

05 Question: 9663번

N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.

N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
05 MySolution: 9663번

#include <iostream>
#include <cmath>
using namespace std;
int col[16];
int n;
int ans = 0;
void queen(int x){
    if(n == x){
        ans++;
    }else{
        for (int i = 0; i < n;i++){
            col[x] = i;
            bool can = true;
            for (int j = 0; j < x;j++){
                if(col[x] == col[j] || abs(col[x] - col[j]) == x - j)
                {
                    can = false;
                    break;
                }
            }
            if(can)
            {
                queen(x + 1);
            }     
        }
    }
}
 
int main(){
    cin >> n;
    queen(0);
    cout << ans;
    return 0;
}


----------------------------------------------------------------------------
----------------------------------------------------------------------------

06 Question: 2580번

스도쿠는 18세기 스위스 수학자가 만든 '라틴 사각형'이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.



나머지 빈 칸을 채우는 방식은 다음과 같다.

각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.



또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.



이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.



게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
06 MySolution: 2580번

#include <iostream>
#include <utility>
#include <vector>
using namespace std;
int board[9][9];
vector<pair<int, int>> points;
int cnt = 0;
bool found = false;
bool check(pair<int, int> p)
{
    int square_x = p.first / 3;
    int square_y = p.second / 3;
    for(int i = 0; i < 9; i++)
    {
        if(board[p.first][i] == board[p.first][p.second] && i != p.second) 
            return false;
        if(board[i][p.second] == board[p.first][p.second] && i != p.first)
            return false;
    }
    for(int i = 3*square_x; i < 3*square_x+3; i++)
        for(int j = 3*square_y; j < 3*square_y+3; j++)
        {
            if(board[i][j] == board[p.first][p.second])
            {
                if(i != p.first && j != p.second)
                    return false;
            }
        }
    return true;
}
void sudoku(int N) {
    if(N == cnt)
    {
        for(int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++)
                cout << board[i][j] << ' ';
            cout << '\n';
        }
        found = true;
        return;
    }
        for(int j = 1; j <= 9; j++)
        {
            board[points[N].first][points[N].second] = j;
            if(check(points[N]))
                sudoku(N+1);
            if(found)
                return;
        }
    board[points[N].first][points[N].second] = 0;
     return;
}
int main() {
    pair<int, int> point;
    for(int i = 0; i < 9; i++)
        for(int j = 0; j < 9; j++)
        {
            cin >> board[i][j];
            if(board[i][j] == 0)
            {
                cnt++;
                point.first = i;
                point.second = j;
                points.push_back(point);
            }
        }
    sudoku(0);
}


----------------------------------------------------------------------------
----------------------------------------------------------------------------
