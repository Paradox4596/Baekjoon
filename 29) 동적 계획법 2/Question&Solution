01 Question: 11066번

소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.

예를 들어, C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.

소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
01 MySolution: 11066번

#include <iostream>
#include <algorithm>
#include <limits.h>

using namespace std;
int t;
int dp[501][501];
int sum[501];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);    
    cin >> t;
    while(t--) {
        int k;
        cin >> k;
        for(int i=1 ; i<=k ; i++) {
            int a;
            cin >> a;
            sum[i] = sum[i-1] + a;
        }
        
        for(int i=1 ; i<k ; i++) {
            for(int x=1 ; x<=k-i ; x++) {
                int y = x+i;
                dp[x][y] = INT_MAX;

                for(int mid = x ; mid<y ; mid++) {
                    dp[x][y] = min(dp[x][y], dp[x][mid] + dp[mid+1][y] + sum[y] - sum[x-1]);
                }
            }
        }
        cout << dp[1][k] << "\n";
    }
    return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 11049번

크기가 N×M인 행렬 A와 M×K인 B를 곱할 때 필요한 곱셈 연산의 수는 총 N×M×K번이다. 행렬 N개를 곱하는데 필요한 곱셈 연산의 수는 행렬을 곱하는 순서에 따라 달라지게 된다.

예를 들어, A의 크기가 5×3이고, B의 크기가 3×2, C의 크기가 2×6인 경우에 행렬의 곱 ABC를 구하는 경우를 생각해보자.

AB를 먼저 곱하고 C를 곱하는 경우 (AB)C에 필요한 곱셈 연산의 수는 5×3×2 + 5×2×6 = 30 + 60 = 90번이다.
BC를 먼저 곱하고 A를 곱하는 경우 A(BC)에 필요한 곱셈 연산의 수는 3×2×6 + 5×3×6 = 36 + 90 = 126번이다.
같은 곱셈이지만, 곱셈을 하는 순서에 따라서 곱셈 연산의 수가 달라진다.

행렬 N개의 크기가 주어졌을 때, 모든 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값을 구하는 프로그램을 작성하시오. 입력으로 주어진 행렬의 순서를 바꾸면 안 된다.
----------------------------------------------------------------------------
02 MySolution: 11049번

#include <iostream>
#include <algorithm>
#include <climits>
 
using namespace std;
 
int n;
const int max_n = 501;
int m[max_n][2];

int dp[max_n][max_n];
 
 
int main(){
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> m[i][0] >> m[i][1];
    }
 
    for(int i=1; i<n; i++){
        for(int j=1; i+j<=n; j++){
            dp[j][i+j] = INT_MAX;
            for(int k=j; k<=i+j; k++){
                dp[j][i+j] = min(dp[j][i+j], dp[j][k] + dp[k+1][i+j] + m[j][0]*m[k][1]*m[i+j][1]);
            }
        }
    }
 
    cout << dp[1][n];
 
    return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

03 Question: 1520번

여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.



현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.

  

지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.
----------------------------------------------------------------------------
03 MySolution: 1520번

#include<iostream>
#include<vector>
using namespace std;
int arr[500][500];
int visit[500][500];
int n, m;
int dx[] = { -1,1,0,0 };
int dy[] = { 0,0,-1,1 };

int dfs(int x, int y) {
    if (x == n - 1 and y == m - 1) return 1;
    if (visit[x][y] == -1) {
        visit[x][y] = 0;
        for (int i = 0; i < 4; i++) {
            int xx = dx[i] + x;
            int yy = dy[i] + y;
            if (xx >= 0 and xx < n and yy>=0 and yy < m) {
                if (arr[xx][yy] < arr[x][y])
                    visit[x][y] += dfs(xx, yy);
            }
        }
    }
    return visit[x][y];
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0); 
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> arr[i][j];
            visit[i][j] = -1;
        }
    }
    
    cout << dfs(0,0) << endl;
    return 0;
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------

04 Question: 2629번

양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.

무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.

구슬이 3g인 경우 아래 <그림 1>과 같이 구슬과 추를 올려놓으면 양팔 저울이 수평을 이루게 된다. 따라서 각각 1g과 4g인 추가 하나씩 있을 경우 주어진 구슬이 3g인지도 확인해 볼 수 있다.



<그림 1> 구슬이 3g인지 확인하는 방법 (
$\boxed{1}$은 1g인 추, 
$\boxed{4}$는 4g인 추, ●은 무게를 확인할 구슬)

<그림 2>와 같은 방법을 사용하면 구슬이 5g인지도 확인할 수 있다. 구슬이 2g이면 주어진 추를 가지고는 확인할 수 없다.

추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.



<그림 2> 구슬이 5g인지 확인하는 방법
----------------------------------------------------------------------------
04 MySolution: 2629번

#include <iostream>

using namespace std;

const int MAX_CNT = 30;
const int MAX_WEIGHT = 500;

int N, M;
int W[MAX_CNT];
bool cache[MAX_CNT + 1][MAX_CNT * MAX_WEIGHT + 1];

void func(int cnt, int weight)
{
    if (cnt > N || cache[cnt][weight]) {
        return;
    }

    cache[cnt][weight] = true;

    func(cnt + 1, weight + W[cnt]);
    func(cnt + 1, weight);
    func(cnt + 1, abs(weight - W[cnt]));
}

int main(void)
{
    cin >> N;
    
    for (int i = 0; i < N; i++) {
        cin >> W[i];
    }

    func(0, 0);

    cin >> M;

    for (int i = 0; i < M; i++) {
        int T; cin >> T;
        if (T > MAX_CNT * MAX_WEIGHT) {
            cout << "N ";
            continue;
        }
        cache[N][T] ? cout << "Y " : cout << "N ";
    }

    return 0;
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------

05 Question: 2293번

n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.
----------------------------------------------------------------------------
05 MySolution: 2293번

#include <iostream>
#include <vector>
using namespace std;

int main() {
	int n, k;
	cin >> n >> k;
	vector<int> arr(n);
	vector<int> dp(k+1);
	for (int i = 0; i < n; i++)
		cin >> arr[i];

	dp[0] = 1;
	for (int i = 0; i < n; i++) {
		for (int j = arr[i]; j <= k; j++) { 
			dp[j] +=dp[j - arr[i]];
		}
	}

	cout<<dp[k]<<endl;
	return 0;
}
----------------------------------------------------------------------------
----------------------------------------------------------------------------
