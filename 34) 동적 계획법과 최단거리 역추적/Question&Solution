01 Question: 12852번

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.
X가 2로 나누어 떨어지면, 2로 나눈다.
1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
----------------------------------------------------------------------------
01 MySolution: 12852번

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int dp[1000001];
int answer;
int n;

void solve(){

    dp[1] = 1;

    for(int i = 2;i<=n;i++){
        dp[i] = i;
    }

    for(int i = 2;i<=n;i++){
        dp[i] = dp[i - 1] + 1;
        if(i % 3 == 0){
            dp[i] = min(dp[i],dp[i / 3] + 1);
        }
        if(i % 2== 0){
            dp[i] = min(dp[i],dp[i / 2] + 1);
        }
    }

    cout<<dp[n] - 1<<endl;

    int count = n;

    cout<<n<<" ";
    
    while(count > 1){
        if(count % 3 == 0 && dp[count / 3] == dp[count] - 1){
            cout<<count / 3<<" ";
            count /= 3;
        }
        else if(count % 2 == 0 && dp[count / 2] == dp[count] - 1){
            cout<<count / 2<<" ";
            count /= 2;
        }
        else {
            cout<<count - 1<<" ";
            count -= 1;
        }
    }
    return;
}

int main(){
    cin>>n;
    
    solve();

    return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

02 Question: 14002번

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.
----------------------------------------------------------------------------
02 MySolution: 14002번

#include<iostream>
#include<vector>
#include<algorithm>
#define endl "\n"
 
using namespace std;
 
int main(){
    int n;
    cin>>n;
    vector<int> sequence(n+1);
 
    vector<int> increase;
    vector<int> DP(n+1);
 
    DP[0] = 1;
    int len = 0;
 
    for(int i = 1;i<=n;i++){
        cin>>sequence[i];
        DP[i] = 1;
        for(int j = 1;j<i;j++){
            if(DP[i]<=DP[j] and sequence[j]<sequence[i]){
                DP[i] = DP[j] + 1;
            }
        }
        len = max(len, DP[i]);
    }
 
    cout<<len<<endl;
    for(int i = n;i>0;i--){
        if(DP[i] == len){
            increase.push_back(sequence[i]);
            len--;
        }
    }
 
    int size = increase.size();
 
    for(int i = increase.size()-1;i>=0;i--){
        cout<<increase[i]<<" ";
    }
 
    return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

03 Question: 14003번

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.
----------------------------------------------------------------------------
03 MySolution: 14003번

#include <iostream>
#include <algorithm>
#include <vector>
#include <stack>
using namespace std;

int main(){
    ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
    int N;
    cin>>N;
    int *num = new int[N];
    int *dp = new int[N];
    int a;
    int idx, dptmp=0;
    vector <int> L;
    stack <int> s;
    vector <int>::iterator p;
    for(int i=0;i<N;i++){
        cin>>a;
        num[i]=a;
        if(L.size()==0) {
            L.push_back(num[i]);
            dp[i]=1;
        }
        else{
            if(L[L.size()-1]<num[i]) {
                L.push_back(num[i]);
                dp[i] = L.size();
            }
            else{
                p = lower_bound(L.begin(),L.end(),num[i]);
                *(p)=num[i];
                dp[i]=p-L.begin()+1;
            }
        }
        if(dp[i]>dptmp) {
            idx = i;
            dptmp = dp[i];
        }
    }
    cout<<L.size();
    s.push(num[idx]);
    for(int i=idx-1;i>=0;i--){
        if(num[i]<num[idx] && dp[i]+1 == dp[idx]){
            idx = i;
            s.push(num[i]);
        }
    }
    cout<<"\n";
    while(!s.empty()){
        cout<<s.top()<<" ";
        s.pop();
    }
    return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------

04 Question: 9252번

LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.
----------------------------------------------------------------------------
04 MySolution: 9252번

#include<iostream>
#include <string>
#include <algorithm>
using namespace std;
string a, b;
string result;
int dp[1001][1001] = { 0, };

int main() {

	ios_base::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	string temp1, temp2;
	cin >> temp1;
	cin >> temp2;
	
	a = ' ' + temp1;
	b = ' ' + temp2;
	
	
	for (int i = 1; i < b.size(); i++) {
		for (int j = 1; j < a.size(); j++) {
			if (a[j] == b[i]) dp[i][j] = dp[i - 1][j - 1] + 1;
			else
				dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
		}
	}

	
	
	int col = a.size() - 1;
	int row = b.size() - 1;

	while (dp[row][col]) {

		if (dp[row][col] == dp[row - 1][col]) {
			row--;
		}
		else if (dp[row][col] == dp[row][col - 1]) {
			col--;
		}
		else {
			result += a[col];
			row--, col--;
		}

	}

	cout << dp[b.size() - 1][a.size() - 1] << endl;
	if (result.size() > 0) {
		reverse(result.begin(), result.end());
		cout << result << endl;
	}
	return 0;
}

----------------------------------------------------------------------------
----------------------------------------------------------------------------
